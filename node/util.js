'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.flattenStyles = exports.setDifference = exports.setIntersection = exports.flattened = exports.flipObj = exports.deepCopy = exports.range = exports.mod = exports.EasingFunctions = exports.checkIsValidSequence = exports.checkIsValidAnimation = undefined;

var _set = require('babel-runtime/core-js/set');

var _set2 = _interopRequireDefault(_set);

var _typeof2 = require('babel-runtime/helpers/typeof');

var _typeof3 = _interopRequireDefault(_typeof2);

var _regenerator = require('babel-runtime/regenerator');

var _regenerator2 = _interopRequireDefault(_regenerator);

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

var _toConsumableArray2 = require('babel-runtime/helpers/toConsumableArray');

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

var _getIterator2 = require('babel-runtime/core-js/get-iterator');

var _getIterator3 = _interopRequireDefault(_getIterator2);

exports.reversed = reversed;
exports.isBaseType = isBaseType;
exports.deepMerge = deepMerge;
exports.select = select;
exports.patch = patch;
exports.applyPatches = applyPatches;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _marked = [reversed].map(_regenerator2.default.mark);

var checkIsValidAnimation = exports.checkIsValidAnimation = function checkIsValidAnimation(animation) {
    if (Array.isArray(animation)) {
        console.log('%cINVALID ANIMATION:', 'color:red', animation);
        console.log('Got an array instead of a single animation object, did you double-nest somthing by forgetting to use ...?');
        throw 'Animation must be passed in as a single Animation object!';
    }
    if (!(animation.type && animation.path)) {
        console.log('%cINVALID ANIMATION:', 'color:red', animation);
        console.log('Got unrecognized aniamtion object missing a type or path.');
        throw 'Animation must be passed in as a single Animation object!';
    }
};

var checkIsValidSequence = exports.checkIsValidSequence = function checkIsValidSequence(animations) {
    if (!Array.isArray(animations)) {
        console.log('%cINVALID ANIMATION:', 'color:red', animations);
        console.log('Got something other than an array.');
        throw 'Sequence must be passed in as an array of Animation objects!';
    }
    if (animations.length && Array.isArray(animations[0])) {
        console.log('%cINVALID ANIMATION:', 'color:red', animations);
        console.log('Got double-nested animation array instead of just an array of objects.');
        throw 'Sequence must be passed in as an array of Animation objects!';
    }
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
        for (var _iterator = (0, _getIterator3.default)(animations), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var animation = _step.value;

            checkIsValidAnimation(animation);
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion && _iterator.return) {
                _iterator.return();
            }
        } finally {
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }

    return true;
};

var EasingFunctions = exports.EasingFunctions = {
    // no easing, no acceleration
    linear: function linear(t) {
        return t;
    },
    // accelerating from zero velocity
    easeInQuad: function easeInQuad(t) {
        return t * t;
    },
    // decelerating to zero velocity
    easeOutQuad: function easeOutQuad(t) {
        return t * (2 - t);
    },
    // acceleration until halfway, then deceleration
    easeInOutQuad: function easeInOutQuad(t) {
        return t < .5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
    },
    // accelerating from zero velocity
    easeInCubic: function easeInCubic(t) {
        return t * t * t;
    },
    // decelerating to zero velocity
    easeOutCubic: function easeOutCubic(t) {
        return --t * t * t + 1;
    },
    // acceleration until halfway, then deceleration
    easeInOutCubic: function easeInOutCubic(t) {
        return t < .5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;
    },
    // accelerating from zero velocity
    easeInQuart: function easeInQuart(t) {
        return t * t * t * t;
    },
    // decelerating to zero velocity
    easeOutQuart: function easeOutQuart(t) {
        return 1 - --t * t * t * t;
    },
    // acceleration until halfway, then deceleration
    easeInOutQuart: function easeInOutQuart(t) {
        return t < .5 ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t;
    },
    // accelerating from zero velocity
    easeInQuint: function easeInQuint(t) {
        return t * t * t * t * t;
    },
    // decelerating to zero velocity
    easeOutQuint: function easeOutQuint(t) {
        return 1 + --t * t * t * t * t;
    },
    // acceleration until halfway, then deceleration
    easeInOutQuint: function easeInOutQuint(t) {
        return t < .5 ? 16 * t * t * t * t * t : 1 + 16 * --t * t * t * t * t;
    }
};

var mod = exports.mod = function mod(num, amt) {
    return (num % amt + amt) % amt;
};

var range = exports.range = function range(num) {
    return [].concat((0, _toConsumableArray3.default)(Array(num).keys()));
};

var deepCopy = exports.deepCopy = function deepCopy(obj) {
    return $.extend(true, {}, obj); // TODO: remove jquery
};

var flipObj = exports.flipObj = function flipObj(obj) {
    return (0, _keys2.default)(obj).reduce(function (acc, key) {
        var val = obj[key];
        acc[val] = key;
        return acc;
    }, {});
};

function reversed(iterator) {
    var idx;
    return _regenerator2.default.wrap(function reversed$(_context) {
        while (1) {
            switch (_context.prev = _context.next) {
                case 0:
                    idx = iterator.length - 1;

                case 1:
                    if (!(idx >= 0)) {
                        _context.next = 7;
                        break;
                    }

                    _context.next = 4;
                    return iterator[idx];

                case 4:
                    idx--;
                    _context.next = 1;
                    break;

                case 7:
                case 'end':
                    return _context.stop();
            }
        }
    }, _marked[0], this);
}

var flattened = exports.flattened = function flattened(array) {
    return [].concat.apply([], array);
};

var setIntersection = exports.setIntersection = function setIntersection(set1, set2) {
    return [].concat((0, _toConsumableArray3.default)(set1)).filter(function (x) {
        return set2.has(x);
    });
};
var setDifference = exports.setDifference = function setDifference(set1, set2) {
    return [].concat((0, _toConsumableArray3.default)(set1)).filter(function (x) {
        return !set2.has(x);
    });
};

var base_types = ['string', 'number', 'boolean', 'symbol', 'function'];
function isBaseType(item) {
    var array_is_basetype = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

    // false if item is a dict, true for everything else
    if (item === null || item === undefined) {
        return true;
    } else if (base_types.indexOf(typeof item === 'undefined' ? 'undefined' : (0, _typeof3.default)(item)) != -1) {
        return true;
    } else if (array_is_basetype && Array.isArray(item)) {
        return true;
    }
    return false;
}

function deepMerge(obj1, obj2) {
    var merge_vals = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

    if (isBaseType(obj1) || isBaseType(obj2)) {
        return obj2;
    } else {
        var obj1_keys = new _set2.default((0, _keys2.default)(obj1));
        var obj2_keys = new _set2.default((0, _keys2.default)(obj2));
        var both_keys = setIntersection(obj1_keys, obj2_keys);
        var only_obj1 = setDifference(obj1_keys, obj2_keys);
        var only_obj2 = setDifference(obj2_keys, obj1_keys);

        var new_obj = {};

        // merge any values that are in both dicts
        if (merge_vals) {
            both_keys.reduce(function (new_obj, key) {
                new_obj[key] = deepMerge(obj1[key], obj2[key]);
                return new_obj;
            }, new_obj);
        }

        // add values only in obj1
        only_obj1.reduce(function (new_obj, key) {
            new_obj[key] = obj1[key];
            return new_obj;
        }, new_obj);

        // add values only in obj2
        only_obj2.reduce(function (new_obj, key) {
            new_obj[key] = obj2[key];
            return new_obj;
        }, new_obj);

        return new_obj;
    }
}

function select(obj, selector) {
    // ({a: {b: 2}}, '/a/b') => 2                   Get obj at specified addr (works with array indicies)
    var keys = void 0;
    if (typeof selector === 'string') {
        if (selector === '/') return obj;
        if (selector[0] !== '/') throw 'Invalid selector! ' + selector;
        keys = selector.split('/').slice(1);
    } else if (Array.isArray(selector)) {
        keys = selector;
    } else {
        throw 'Invalid selector, must be string /path or array of keys! ' + selector;
    }
    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
        for (var _iterator2 = (0, _getIterator3.default)(keys), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var key = _step2.value;

            obj = obj[key];
        }
    } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion2 && _iterator2.return) {
                _iterator2.return();
            }
        } finally {
            if (_didIteratorError2) {
                throw _iteratorError2;
            }
        }
    }

    return obj;
}

function patch(obj, selector, new_val) {
    var merge = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    var mkpath = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
    var deepcopy = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;

    // ({a: {b: 2}}, '/a/b', 4) => {a: {b: 4}}      Set obj at specified addr (works with array indicies)
    var keys = void 0;
    if (typeof selector === 'string') {
        if (selector === '/') return new_val;
        if (!selector || selector[0] !== '/') throw 'Invalid selector! ' + selector;
        keys = selector.split('/').slice(1);
    } else if (Array.isArray(selector)) {
        keys = [].concat((0, _toConsumableArray3.default)(selector));
    } else {
        throw 'Invalid selector, must be string /path or array of keys! ' + selector;
    }
    var last_key = keys.pop();
    if (last_key == '') {
        console.log({ obj: obj, selector: selector, new_val: new_val, merge: merge, mkpath: mkpath });
        throw 'Patch paths must not have trailing slashes or empty keys!';
    }
    var parent = obj;
    var _iteratorNormalCompletion3 = true;
    var _didIteratorError3 = false;
    var _iteratorError3 = undefined;

    try {
        for (var _iterator3 = (0, _getIterator3.default)(keys), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
            var key = _step3.value;

            // create path if any point is missing
            if (mkpath && (parent[key] === undefined || parent[key] === null) || isBaseType(parent[key], false)) {
                parent[key] = {};
            }
            parent = parent[key];
        }
    } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion3 && _iterator3.return) {
                _iterator3.return();
            }
        } finally {
            if (_didIteratorError3) {
                throw _iteratorError3;
            }
        }
    }

    if (merge) {
        parent[last_key] = deepMerge(parent[last_key], new_val);
    } else {
        parent[last_key] = new_val;
    }
    return deepcopy ? $.extend(true, {}, obj) : obj;
}

var css_transform_str = {
    scale: function scale(_scale) {
        return 'scale(' + _scale + ')';
    },
    perspective: function perspective(px) {
        return 'perspective(' + px + ')';
    },
    translate: function translate(_ref) {
        var left = _ref.left,
            top = _ref.top;
        return 'translate(' + left + ', ' + top + ')';
    },
    translate3d: function translate3d(_ref2) {
        var x = _ref2.x,
            y = _ref2.y,
            z = _ref2.z;
        return 'translate3d(' + x + ', ' + y + ', ' + z + ')';
    },
    rotate: function rotate(rotation) {
        return 'rotate(' + rotation + ')';
    },
    rotate3d: function rotate3d(_ref3) {
        var x = _ref3.x,
            y = _ref3.y,
            z = _ref3.z;
        return 'rotate3d(' + x + ', ' + y + ', ' + z + ')';
    },
    skew: function skew(_ref4) {
        var x = _ref4.x,
            y = _ref4.y;
        return 'skew(' + x + ', ' + y + ')';
    },
    scale3d: function scale3d(_ref5) {
        var x = _ref5.x,
            y = _ref5.y,
            z = _ref5.z;
        return 'scale3d(' + x + ', ' + y + ', ' + z + ')';
    }
    // TODO: add more css transform types?
};

var css_animation_str = function css_animation_str(_ref6) {
    var name = _ref6.name,
        duration = _ref6.duration,
        curve = _ref6.curve,
        delay = _ref6.delay,
        playState = _ref6.playState;
    return name + ' ' + duration + 'ms ' + curve + ' -' + delay + 'ms ' + playState;
};

var flattenTransform = function flattenTransform(transform) {
    // WARNING: optimized code, do not convert to map() without profiling
    // flatten transforms from a dict to a string
    // converts {style: {transform: {translate: {left: '0px', top: '10px'}, rotate: '10deg'}}}
    //      =>  {style: {transform: 'translate(0px, 10px) rotate(10deg)'}}

    var css_transform_funcs = [];
    var _iteratorNormalCompletion4 = true;
    var _didIteratorError4 = false;
    var _iteratorError4 = undefined;

    try {
        for (var _iterator4 = (0, _getIterator3.default)((0, _keys2.default)(transform)), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
            var key = _step4.value;

            if (transform[key] === null) continue;
            var order = transform[key].order;
            if (typeof order === 'number') {
                // deterministic ordering via order: key
                css_transform_funcs[order] = css_transform_str[key](transform[key]);
            } else {
                css_transform_funcs.push(css_transform_str[key](transform[key]));
            }
        }
    } catch (err) {
        _didIteratorError4 = true;
        _iteratorError4 = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion4 && _iterator4.return) {
                _iterator4.return();
            }
        } finally {
            if (_didIteratorError4) {
                throw _iteratorError4;
            }
        }
    }

    return css_transform_funcs.filter(Boolean).join(' ');
};

var flattenAnimation = function flattenAnimation(animation) {
    // WARNING: optimized code, do not convert to map() without profiling
    // flatten animations from a dict to a string
    // converts {style: {animations: {blinker: {name: blinker, duration: 1000, curve: 'linear', delay: 767}, ...}}}
    //      =>  {style: {animation: blinker 1000ms linear -767ms paused, ...}}

    var css_animation_funcs = [];
    var _iteratorNormalCompletion5 = true;
    var _didIteratorError5 = false;
    var _iteratorError5 = undefined;

    try {
        for (var _iterator5 = (0, _getIterator3.default)((0, _keys2.default)(animation)), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
            var key = _step5.value;

            if (animation[key] === null) continue;
            var order = animation[key].order;
            if (typeof order === 'number') {
                // deterministic ordering via order: key
                css_animation_funcs[order] = css_animation_str(animation[key]);
            } else {
                css_animation_funcs.push(css_animation_str(animation[key]));
            }
        }
    } catch (err) {
        _didIteratorError5 = true;
        _iteratorError5 = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion5 && _iterator5.return) {
                _iterator5.return();
            }
        } finally {
            if (_didIteratorError5) {
                throw _iteratorError5;
            }
        }
    }

    return css_animation_funcs.filter(Boolean).join(', ');
};

var flattenIfNotFlattened = function flattenIfNotFlattened(state, path, flatten_func) {
    var state_slice = select(state, path);
    if (typeof state_slice !== 'string') {
        patch(state, path, flatten_func(state_slice), false, false, false);
    }
};

var flattenStyles = exports.flattenStyles = function flattenStyles(state, paths_to_flatten) {
    // WARNING: highly optimized code, profile before changing anything
    // this converts the styles stored as dicts in the state tree, to the strings
    // that react components expect as CSS style values
    var _iteratorNormalCompletion6 = true;
    var _didIteratorError6 = false;
    var _iteratorError6 = undefined;

    try {
        for (var _iterator6 = (0, _getIterator3.default)(paths_to_flatten), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
            var path = _step6.value;

            var transform_idx = path.lastIndexOf('transform');
            if (transform_idx != -1) {
                var path_to_transform = path.slice(0, transform_idx + 1);
                flattenIfNotFlattened(state, path_to_transform, flattenTransform);
                continue;
            }
            var animation_idx = path.lastIndexOf('animation');
            if (animation_idx != -1) {
                var path_to_animation = path.slice(0, animation_idx + 1);
                flattenIfNotFlattened(state, path_to_animation, flattenAnimation);
                continue;
            }
        }
    } catch (err) {
        _didIteratorError6 = true;
        _iteratorError6 = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion6 && _iterator6.return) {
                _iterator6.return();
            }
        } finally {
            if (_didIteratorError6) {
                throw _iteratorError6;
            }
        }
    }

    return state;
};

var shouldFlatten = function shouldFlatten(split_path) {
    // WARNING: highly optimized code, profile before changing anything
    // check to see if a given path introduces some CSS state that needs to be
    // converted from an object to a css string, e.g. {style: transform: translate: {top: 0, left: 0}}
    var style_key = split_path.lastIndexOf('style');
    return style_key != -1 && (split_path[style_key + 1] == 'transform' || split_path[style_key + 1] == 'animation');
};

function applyPatches(obj, patches) {
    var flatten_styles = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

    // WARNING: highly optimized code, profile before changing anything
    var output = {};
    var paths_to_flatten = [];

    // O(n) application of patches onto a single object
    var _iteratorNormalCompletion7 = true;
    var _didIteratorError7 = false;
    var _iteratorError7 = undefined;

    try {
        for (var _iterator7 = (0, _getIterator3.default)(patches), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
            var _patch = _step7.value;

            // deepcopy to prevent later patches from mutating previous object values
            var patch_val = _patch.value;
            if (patch_val !== null && (typeof patch_val === 'undefined' ? 'undefined' : (0, _typeof3.default)(patch_val)) === 'object') {
                // unfortunately this is not very optimizable since dont know
                // the structure beforehand. Do not use JSON.stringify+parse because
                // Date, function, and Infinity objects dont get safely converted.
                // jQuery is significantly faster than lodash cloneDeep
                patch_val = $.extend(true, {}, patch_val);
            }
            var keys = [].concat((0, _toConsumableArray3.default)(_patch.split_path));

            if (flatten_styles && shouldFlatten(keys)) paths_to_flatten.push(keys);

            var final_key = keys.pop();
            // get to the end of the list of paths
            var parent = output;
            var _iteratorNormalCompletion8 = true;
            var _didIteratorError8 = false;
            var _iteratorError8 = undefined;

            try {
                for (var _iterator8 = (0, _getIterator3.default)(keys), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
                    var key = _step8.value;

                    if (parent[key] === undefined || parent[key] === null || isBaseType(parent[key], false)) {
                        parent[key] = {};
                    }
                    parent = parent[key];
                }
            } catch (err) {
                _didIteratorError8 = true;
                _iteratorError8 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion8 && _iterator8.return) {
                        _iterator8.return();
                    }
                } finally {
                    if (_didIteratorError8) {
                        throw _iteratorError8;
                    }
                }
            }

            parent[final_key] = patch_val;
        }
    } catch (err) {
        _didIteratorError7 = true;
        _iteratorError7 = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion7 && _iterator7.return) {
                _iterator7.return();
            }
        } finally {
            if (_didIteratorError7) {
                throw _iteratorError7;
            }
        }
    }

    if (flatten_styles) return flattenStyles(output, paths_to_flatten);
    return output;
}
